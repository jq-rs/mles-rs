<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mles.io</title>
<link href="css/style.css" rel="stylesheet"></link>
<style>
#bwidth {
    margin: auto;
    width: 85%;
    padding: 10px;
}
</style>
</head>
<body>
<div class="container">
<div id="bwidth">
<div>
<img src="images/mles_logo_final.png" alt="Mles logo" width="100" />
</div>
<header>
    <h1>Mles: Modern Lightweight Channel Service</h1>
</header>

<main>
    <section id="introduction">
        <h2>Introduction</h2>
        <p>Mles (Modern Lightweight channEl Service) is a professional-grade distributed publish-subscribe data service built on Rust, Tokio, and Serde. This lightweight yet robust solution provides authenticated messaging channels that operate seamlessly across IPv4 and IPv6 networks over TCP, ensuring reliable data transfer on all Rust-supported platforms including Linux, macOS, and Windows.</p>
    </section>

    <section id="why-mles">
        <h2>Why Choose Mles?</h2>
        <p>Mles delivers a streamlined publish-subscribe architecture for applications requiring reliable channel-based message exchange. The connection model is designed for simplicity and efficiency: clients connect directly to their desired channel and immediately begin exchanging messages without additional setup procedures. When finished, clients simply close their connection.</p>

        <p>Key advantages include:</p>
        <ul>
            <li>Exceptional scalability through advanced connection handling built on Tokio futures</li>
            <li>Format-agnostic message passing that preserves client data structure integrity</li>
            <li>Modern, high-performance authentication mechanisms effective even with minimal inputs</li>
            <li>Lightweight Rust-based architecture delivering superior performance compared to alternatives</li>
        </ul>
    </section>

    <section id="overview">
        <h2>Technical Overview</h2>
        <p>The Mles protocol leverages TLS WebSocket session packet forwarding within channels, using client identification and channel fields for routing. The reference server implementation is developed in safe Rust code that eliminates blocking operations while supporting robust session authentication between Mles clients and servers.</p>

        <p>The dual-layer authentication architecture provides:</p>
        <ul>
            <li>Level 1: Server-client authentication</li>
            <li>Level 2: Client-client authentication</li>
        </ul>

        <p>This approach enables clients to authenticate each other independently from servers and implement custom protocols over the Mles foundation. Clients maintain complete freedom to select their preferred data structures for message exchange.</p>
    </section>

    <section id="protocol">
        <h2>Protocol Specification</h2>
        <p>The Mles first frame employs a JSON-based data structure consisting of a (uid, channel, auth) value triplet. The uid and channel fields are UTF-8 strings, while the optional auth field facilitates additional client-server authentication beyond TLS when required.</p>

        <p>This represents the only mandatory message type clients need to implement. The protocol intentionally omits internal message types like "join" or "leave" notifications and avoids flags by design, resulting in streamlined message processing. Following first frame authentication, the Mles server efficiently forwards subsequent frames to all channel subscribers.</p>

        <p>First frame JSON protocol header:</p>
        <pre>
{
    "uid":"&lt;user identification&gt;",
    "channel":"&lt;selected channel&gt;",
    "auth":"&lt;optional authentication hash&gt;"
}
        </pre>

	<p>The Mles protocol and reference implementation have reached stability with the v2.0 release. For implementation details, visit <a href="https://github.com/jq-rs/mles-rs">github.com/jq-rs/mles-rs</a> and the <a href="https://mles.io/blog">mles.io/blog</a>. Stay updated with the latest news on the <a href="https://lemmy.world/c/mles/">/c/mles</a> channel.</p>
    </section>

    <section id="advanced-features">
        <h2>Advanced Features</h2>

        <h3>Server Connectivity with Proxy-Clients</h3>
        <p>In Mles v2, there has been a significant architectural advancement in how servers connect. Instead of the previous model where servers connected directly as peers and shared all channels, the new approach implements a proxy-client model that enables channel-specific connections between servers.</p>

        <p>This proxy-client architecture offers several benefits:</p>
        <ul>
            <li>Granular control: Only specific channels are shared between servers</li>
            <li>Reduced network traffic: Messages are only forwarded for channels that need to be shared</li>
            <li>Enhanced privacy: Channels can remain isolated to specific servers</li>
            <li>Flexible topology: Custom network configurations can be created at the channel level</li>
        </ul>

        <p>The proxy-client functions as a standard client from the perspective of both servers, but its role is to bridge a specific channel between them. Multiple proxy-clients can connect different channel combinations across various servers, creating a highly customizable distribution network.</p>

        <h3>Message History</h3>
        <p>Mles servers and their connected channels can provide message history functionality to deliver previous messages to new client connections. Unlike conventional approaches, Mles does not maintain a queue that tracks message delivery status. Instead, it efficiently resends available history to reconnecting clients, including proxy-clients.</p>

        <p>This streamlined approach guarantees that clients receive all channel history following a connection interruption. Clients can determine if new messages were posted during disconnection periods and identify whether their own messages require retransmission. While these capabilities are available, they remain optional for clients that don't require such functionality.</p>

        <p>In distributed environments, proxy-clients also facilitate resynchronization of channel history during scenarios such as server restarts, providing resilience without requiring client intervention.</p>
    </section>

    <section id="use-cases">
        <h2>Implementation Scenarios</h2>
        <p>Reliable, authenticated, and scalable data distribution is essential for many modern applications. Mles provides an ideal foundation for such services.</p>

        <h3>Simple Channel Configuration</h3>
        <p>In the basic implementation, multiple clients connect directly to a public server on their designated channel. Each client communicates with others on the same channel through the server.</p>

        <h3>Distributed Channel Configuration</h3>
        <p>For more complex deployments, channels can be selectively distributed across multiple servers using proxy-clients. Clients may connect to any server in the network while maintaining access to shared channels.</p>

        <p>Any hierarchical arrangement of Mles servers with proxy-client connections provides efficient message distribution across the network.</p>

        <h3>Potential Applications</h3>
        <p>Services that would benefit from Mles architecture include:</p>
        <ul>
            <li>Configuration distribution systems</li>
            <li>IoT telemetry platforms</li>
            <li>Any publish-subscribe service without database requirements</li>
        </ul>

        <p>Mles is particularly well-suited for applications with numerous clients distributed across a limited number of channels. Since the channel joining mechanism operates per connection and channels cannot be multiplexed on a single connection, Mles may not be optimal for clients requiring access to a very large number of channels simultaneously.</p>
    </section>

    <section id="client-design">
        <h2>Client Protocol Design Considerations</h2>
        <p>Developing a lightweight Mles client is straightforward, requiring only knowledge of the data structure to be exchanged with other clients. However, when implementing history functionality, clients should anticipate potential message duplication during error recovery scenarios.</p>

        <p>Recommended design practices include:</p>
        <ul>
            <li>Implementing per-user sequence numbers to identify and filter duplicate messages</li>
            <li>Developing resynchronization capabilities for reconnecting to the message history</li>
            <li>Creating mechanisms to retransmit lost messages when high reliability is required</li>
        </ul>

        <p>For channel membership awareness, clients can monitor initial frames sent during connection attempts. These frames provide user and channel information that allows clients to track active subscribers. For departure notification, either a custom messaging protocol or keepalive mechanism can be implemented at the client layer.</p>

	<p>The open-source <a href="https://github.com/jq-rs/mles-client">mles-client</a> and <a href="app.html">MlesTalk</a> applications provide reference implementations demonstrating these concepts.</p>
    </section>

    <section id="future">
        <h2>Future Development</h2>
        <p>The reference implementation roadmap includes performance optimizations and resilience enhancements. Additional extensions may be considered provided they maintain alignment with the core principles of Mles.</p>

        <p>To preserve the lightweight, compatible, and understandable nature of the service, the Mles protocol itself is stabilized as of the 2.0 release, with no further changes permitted. Standardization may be pursued to formalize this commitment.</p>

        <p>Client-side innovation remains unrestricted, with new service types and protocol implementations welcome as second-level additions. We encourage sharing client implementations as examples for the community. Please inform us of your developments in this area.</p>
    </section>
</main>

<footer>
    <p>&copy; Mles.io. All rights reserved.</p>
</footer>
</div>
</div>
</body>
</html>


